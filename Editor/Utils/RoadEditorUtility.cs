// 文件路径: Editor/RoadEditorUtility.cs
using UnityEngine;
using UnityEditor;
using System.IO;
using System.Collections.Generic;

namespace RoadSystem.Editor
{
    public static class RoadEditorUtility
    {
        private const string AutoGeneratedLayerPath = "Assets/RoadCreator/Generated/TerrainLayers";

        public static TerrainLayer GetOrCreateTerrainLayerFromMaterial(Material material)
        {
            if (material == null || !material.HasProperty("_MainTex") || material.mainTexture == null)
            {
                return null;
            }

            // 确保目录存在
            if (!Directory.Exists(AutoGeneratedLayerPath))
            {
                Directory.CreateDirectory(AutoGeneratedLayerPath);
            }

            var texture = material.mainTexture;
            string assetPath = Path.Combine(AutoGeneratedLayerPath, $"TL_{texture.name}.asset");

            // 检查是否已存在
            TerrainLayer existingLayer = AssetDatabase.LoadAssetAtPath<TerrainLayer>(assetPath);
            if (existingLayer != null)
            {
                // 可选：检查属性是否一致，不一致则更新
                if (existingLayer.diffuseTexture != texture ||
                    !Mathf.Approximately(existingLayer.tileSize.x, 1f / material.mainTextureScale.x) ||
                    !Mathf.Approximately(existingLayer.tileSize.y, 1f / material.mainTextureScale.y))
                {
                    // 更新现有资源
                    UpdateTerrainLayer(existingLayer, material);
                }
                return existingLayer;
            }

            // 如果不存在，则创建新的
            Debug.Log($"<color=green>自动创建 TerrainLayer: {assetPath}</color>");
            TerrainLayer newLayer = new TerrainLayer();
            UpdateTerrainLayer(newLayer, material);

            AssetDatabase.CreateAsset(newLayer, assetPath);
            AssetDatabase.SaveAssets();

            return newLayer;
        }

        private static void UpdateTerrainLayer(TerrainLayer layer, Material material)
        {
            layer.diffuseTexture = material.mainTexture as Texture2D;

            // Tiling 在 Shader 中是 _MainTex_ST (scale.xy, offset.zw)
            // TerrainLayer.tileSize 是纹理重复多少次来填满一个单位
            // 所以 tiling.x = 1 / tileSize.x
            // 因此 tileSize.x = 1 / tiling.x
            float tileX = (material.mainTextureScale.x == 0) ? 1f : 1f / material.mainTextureScale.x;
            float tileY = (material.mainTextureScale.y == 0) ? 1f : 1f / material.mainTextureScale.y;
            layer.tileSize = new Vector2(tileX, tileY);

            // 你还可以从材质中同步法线贴图、金属度等属性
            if (material.HasProperty("_BumpMap") && material.GetTexture("_BumpMap") != null)
            {
                layer.normalMapTexture = material.GetTexture("_BumpMap") as Texture2D;
            }

            if (material.HasProperty("_Metallic"))
            {
                layer.metallic = material.GetFloat("_Metallic");
            }

            if (material.HasProperty("_Glossiness"))
            {
                layer.smoothness = material.GetFloat("_Glossiness");
            }

            EditorUtility.SetDirty(layer);
        }
        public static Vector3 GetDisplayPoint(IReadOnlyList<RoadControlPoint> points, float t, RoadConfig config, Transform transform)
        {
            if (points == null || points.Count == 0 || config == null || transform == null)
            {
                return Vector3.zero;
            }

            // 步骤 1: 使用与 Job 中相同的线性插值逻辑获取局部坐标点
            Vector3 localPos = SplineUtility.GetPoint(points, t);

            // 步骤 2: 将局部坐标转换为世界坐标
            Vector3 worldPos = transform.TransformPoint(localPos);

            // 步骤 3: (可选) 根据配置进行地形贴合
            if (config.conformToTerrainUndulations && config.terrainConformity > 0 && Terrain.activeTerrain != null)
            {
                Terrain terrain = Terrain.activeTerrain;
                // 获取地形在当前点的世界高度
                float terrainHeight = terrain.SampleHeight(worldPos) + terrain.transform.position.y;
                // 根据贴合度 (Conformity) 在原始高度和地形高度之间进行插值
                worldPos.y = Mathf.Lerp(worldPos.y, terrainHeight, config.terrainConformity);
            }

            // 步骤 4: 应用最终的预览高度偏移
            worldPos.y += config.previewHeightOffset;

            return worldPos;
        }
    }
}